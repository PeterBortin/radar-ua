<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Tactical Map -- —Ü–≤–µ—Ç–Ω—ã–µ —Ç–æ—á–∫–∏ + –≥–∞—Ä–º–æ–Ω–∏—á–Ω—ã–π –Ω–∏–∑</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"/>

<style>
html,body{margin:0;padding:0;height:100%;background:#111;font-family:'Segoe UI',Arial,sans-serif;}
#map{height:100%;width:100%;}

/* –ì–∞—Ä–º–æ–Ω–∏—á–Ω–∞—è –Ω–∏–∂–Ω—è—è –ø–∞–Ω–µ–ª—å -- —Ü–µ–Ω—Ç—Ä, –∫–æ–º–ø–∞–∫—Ç–Ω–æ */
.control-panel{
  position:absolute;
  bottom:20px;
  left:50%;
  transform:translateX(-50%);
  background:rgba(20,20,20,0.85);
  backdrop-filter:blur(8px);
  border-radius:100px;
  padding:8px 16px;
  border:1px solid #3a3a3a;
  box-shadow:0 8px 20px rgba(0,0,0,0.6);
  z-index:1000;
  display:flex;
  gap:24px;
  align-items:center;
  font-size:13px;
}

.select-group{
  display:flex;
  gap:8px;
}
.select-group select{
  background:#1e1e1e;
  color:white;
  border:1px solid #444;
  border-radius:40px;
  padding:8px 18px;
  font-size:13px;
  font-weight:400;
  cursor:pointer;
  outline:none;
  min-width:110px;
  transition:0.15s;
}
.select-group select:hover{background:#2a2a2a;border-color:#666;}

.button-group{
  display:flex;
  gap:8px;
}
.button-group button{
  background:#1e1e1e;
  border:1px solid #444;
  color:#eee;
  border-radius:40px;
  padding:8px 22px;
  font-size:13px;
  font-weight:500;
  cursor:pointer;
  display:flex;
  align-items:center;
  gap:8px;
  transition:0.15s;
  letter-spacing:0.3px;
}
.button-group button i{font-size:12px;}
.button-group button:hover{
  background:#2d2d2d;
  color:white;
  border-color:#777;
}
.reset-btn{color:#ffb0b0;}
.reset-btn:hover{background:#4a1a1a !important;border-color:#c44 !important;}

/* –ö–Ω–æ–ø–∫–∏ –∑—É–º–∞ —Å–ø—Ä–∞–≤–∞ –≤–Ω–∏–∑—É (–Ω–∞–¥ –ø–∞–Ω–µ–ª—å—é) */
.zoom-ui{
  position:absolute;
  bottom:100px;
  right:20px;
  display:flex;
  flex-direction:column;
  gap:6px;
  z-index:1000;
}
.zoom-ui button{
  width:40px;
  height:40px;
  border-radius:40px;
  background:rgba(20,20,20,0.85);
  backdrop-filter:blur(8px);
  border:1px solid #444;
  color:white;
  font-size:16px;
  cursor:pointer;
  display:flex;
  align-items:center;
  justify-content:center;
  transition:0.15s;
}
.zoom-ui button:hover{background:#2d2d2d;border-color:#777;}

/* –¢—É–ª—Ç–∏–ø –±–µ–∑ –æ–±–≤–æ–¥–∫–∏ */
.tooltip{
  position:absolute;
  background:rgba(30,30,30,0.9);
  color:#eee;
  padding:4px 10px;
  border-radius:20px;
  font-size:11px;
  pointer-events:none;
  white-space:nowrap;
  z-index:2000;
  backdrop-filter:blur(2px);
  border:none;
  box-shadow:0 2px 6px black;
}

/* —Ç–æ—á–∫–∏ –Ω–∞ –∫–∞—Ä—Ç–µ -- —Ü–≤–µ—Ç –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ç–∏–ø–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ (–≤—Ä–µ–º–µ–Ω–Ω–æ) */
.temp-point{
  border-radius:50%;
  border:1px solid rgba(255,255,255,0.5);
}

@media(max-width:650px){
  .control-panel{flex-direction:column;gap:12px;border-radius:30px;width:95%;padding:15px;}
  .zoom-ui{bottom:200px;}
}
</style>
</head>
<body>

<div id="map"></div>

<!-- –ó—É–º —Å–ø—Ä–∞–≤–∞ –≤–Ω–∏–∑—É -->
<div class="zoom-ui">
  <button onclick="map.zoomIn()"><i class="fas fa-plus"></i></button>
  <button onclick="map.zoomOut()"><i class="fas fa-minus"></i></button>
</div>

<!-- –ù–∏–∂–Ω—è—è –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è (–≥–∞—Ä–º–æ–Ω–∏—á–Ω–∞—è) -->
<div class="control-panel">
  <div class="select-group">
    <select id="category">
      <option value="drone">üöÅ –ë–ü–õ–ê</option>
      <option value="cr">‚ö° –ö–†</option>
      <option value="br">üî• –ë–†</option>
    </select>
    <select id="speedSelect"></select>
  </div>
  
  <div class="button-group">
    <button onclick="startObject()"><i class="fas fa-play"></i> –°—Ç–∞—Ä—Ç</button>
    <button class="reset-btn" onclick="resetAll()"><i class="fas fa-trash-alt"></i> –°–±—Ä–æ—Å</button>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
const TIME_SCALE = 60;
const map = L.map('map', {zoomControl: false}).setView([49,31],6);
L.tileLayer(
'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',
{attribution:'¬© OpenStreetMap & CartoDB'}
).addTo(map);

// –≠—Ñ—Ñ–µ–∫—Ç (–¥—ã–º/—á–∞—Å—Ç–∏—Ü—ã)
function createExplosionEffect(latlng, color) {
  const particles = 12;
  for(let i=0; i<particles; i++) {
    let angle = Math.random() * 2 * Math.PI;
    let dist = Math.random() * 200;
    let offsetLat = (Math.sin(angle) * dist) / 111000;
    let offsetLng = (Math.cos(angle) * dist) / (111000 * Math.cos(latlng.lat * Math.PI/180));
    let particleLatLng = [latlng.lat + offsetLat, latlng.lng + offsetLng];
    
    let particle = L.circleMarker(particleLatLng, {
      radius: Math.random() * 6 + 2,
      color: color,
      fillColor: color,
      fillOpacity: 0.7,
      weight: 0.5
    }).addTo(map);
    
    let life = 1.0;
    function fade() {
      life -= 0.025;
      if(life <= 0) {
        map.removeLayer(particle);
        return;
      }
      particle.setStyle({
        fillOpacity: life * 0.6,
        radius: (Math.random() * 5 + 2) * life
      });
      requestAnimationFrame(fade);
    }
    requestAnimationFrame(fade);
  }
}

const speedOptions={
  drone:[80,150,300],
  cr:[700, 900, 1200],
  br:[3000,5000,10000, 15000]
};

const impactRadius={
  drone:40,
  cr:120,
  br:300
};

const categorySelect=document.getElementById("category");
const speedSelect=document.getElementById("speedSelect");

function updateSpeedOptions(){
  speedSelect.innerHTML="";
  speedOptions[categorySelect.value].forEach(s=>{
    const o=document.createElement("option");
    o.value=s;
    o.textContent=s+" –∫–º/—á";
    speedSelect.appendChild(o);
  });
}
updateSpeedOptions();
categorySelect.addEventListener("change",updateSpeedOptions);

let tempPoints=[];
let tempMarkers=[]; // —á—Ç–æ–±—ã —É–¥–∞–ª—è—Ç—å –ø—Ä–∏ —Å–º–µ–Ω–µ —Ç–∏–ø–∞ –∏–ª–∏ —Å–±—Ä–æ—Å–µ
let activeObjects=[];

// –§—É–Ω–∫—Ü–∏—è —Ü–≤–µ—Ç–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞
function getCurrentTypeColor(){
  const type = categorySelect.value;
  if(type==="drone") return "#00ffff";
  if(type==="cr") return "#ffaa00";
  if(type==="br") return "#ff4444";
  return "#ffffff";
}

// –ü–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ç–æ—á–µ–∫ –ø—Ä–∏ —Å–º–µ–Ω–µ —Ç–∏–ø–∞ (–æ–±–Ω–æ–≤–ª—è–µ–º —Ü–≤–µ—Ç)
function refreshTempPointsColor(){
  const color = getCurrentTypeColor();
  tempMarkers.forEach(m => {
    m.setStyle({color: color, fillColor: color});
  });
}

categorySelect.addEventListener("change", ()=>{
  updateSpeedOptions();
  refreshTempPointsColor();
});

map.on("click",e=>{
  if(categorySelect.value === "br" && tempPoints.length >= 2) {
    alert("–î–ª—è –ë–† —Ç–æ–ª—å–∫–æ –¥–≤–µ —Ç–æ—á–∫–∏: —Å—Ç–∞—Ä—Ç –∏ —Ñ–∏–Ω–∏—à");
    return;
  }
  const latlng = [e.latlng.lat, e.latlng.lng];
  tempPoints.push(latlng);
  
  const color = getCurrentTypeColor();
  const marker = L.circleMarker(latlng, {
    radius: 5,
    color: color,
    fillColor: color,
    fillOpacity: 0.9,
    weight: 1.5,
    className: 'temp-point'
  }).addTo(map);
  tempMarkers.push(marker);
});

function startObject(){
  if(tempPoints.length<2){alert("–ú–∏–Ω–∏–º—É–º 2 —Ç–æ—á–∫–∏"); return;}
  const type = categorySelect.value;
  const speed = parseInt(speedSelect.value);

  const obj = {
    type:type,
    points:[...tempPoints],
    speed:speed,
    marker:L.circleMarker(tempPoints[0],{
      radius:6,
      color:getColor(type),
      fillColor:getColor(type),
      fillOpacity:1,
      weight:1.5
    }).addTo(map),
    passedLine:null,
    remainingLine:null,
    impactCircle:null,
    startTime:performance.now(),
    totalDistance:calcTotal(tempPoints),
    finished:false,
    tooltip:createTooltip(tempPoints[0])
  };

  obj.marker.bringToFront();
  activeObjects.push(obj);
  
  // —É–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ç–æ—á–∫–∏
  tempMarkers.forEach(m=>map.removeLayer(m));
  tempMarkers = [];
  tempPoints = [];
  
  animateObject(obj);
}

function createTooltip(latlng){
  const div = document.createElement("div");
  div.className="tooltip";
  div.style.left="0px"; div.style.top="0px";
  div.innerHTML = `0:00:00 | 0 –∫–º/—á`;
  document.body.appendChild(div);
  return div;
}

function updateTooltip(obj,latlng,currentSpeed,time){
  const point = map.latLngToContainerPoint(latlng);
  obj.tooltip.style.left = (point.x+12)+"px";
  obj.tooltip.style.top = (point.y-25)+"px";
  obj.tooltip.innerHTML = `${formatTime(time)} | ${currentSpeed.toFixed(0)} –∫–º/—á`;
}

function removeTooltip(obj){
  if(obj.tooltip) document.body.removeChild(obj.tooltip);
}

function formatTime(hours){
  const totalSec = Math.floor(hours*3600);
  const h=Math.floor(totalSec/3600);
  const m=Math.floor((totalSec%3600)/60);
  const s=totalSec%60;
  return `${h}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
}

function animateObject(obj){
  function frame(){
    if(obj.finished) return;

    const now = performance.now();
    const hours = ((now-obj.startTime)/1000/3600)*TIME_SCALE;

    let traveled;
    if(obj.type==="br"){
      traveled = getBRDistance(obj, hours);
    } else traveled = obj.speed*hours;

    if(traveled>=obj.totalDistance){
      finishObject(obj);
      return;
    }

    let acc=0;
    for(let i=0;i<obj.points.length-1;i++){
      const seg=getDistance(obj.points[i],obj.points[i+1]);
      if(acc+seg>=traveled){
        const r=(traveled-acc)/seg;
        const lat=obj.points[i][0]+(obj.points[i+1][0]-obj.points[i][0])*r;
        const lng=obj.points[i][1]+(obj.points[i+1][1]-obj.points[i][1])*r;
        const pos=[lat,lng];

        obj.marker.setLatLng(pos);
        obj.marker.bringToFront();

        drawLines(obj,i,pos);
        updateTooltip(obj,pos,obj.speed,hours);
        break;
      }
      acc+=seg;
    }
    requestAnimationFrame(frame);
  }
  frame();
}

function getBRDistance(obj,hours){
  const accelPhase = 5/3600;
  if(hours < accelPhase) {
    return obj.speed * hours * 0.3;
  } else {
    return obj.speed * (hours - accelPhase*0.5);
  }
}

function drawLines(obj,index,currentPos){
  if(obj.passedLine) map.removeLayer(obj.passedLine);
  if(obj.remainingLine) map.removeLayer(obj.remainingLine);

  const passed = obj.points.slice(0,index+1);
  passed.push(currentPos);
  const remaining = obj.points.slice(index+1);

  obj.passedLine = L.polyline(passed,{color:getColor(obj.type), weight:3, opacity:0.8}).addTo(map);

  if(remaining.length>0){
    obj.remainingLine = L.polyline([currentPos,...remaining],{
      color:getColor(obj.type),
      dashArray:"6,6",
      weight:2,
      opacity:0.5
    }).addTo(map);
  }
}

function finishObject(obj){
  obj.finished=true;
  if(obj.marker) map.removeLayer(obj.marker);
  if(obj.remainingLine) map.removeLayer(obj.remainingLine);
  if(obj.passedLine) map.removeLayer(obj.passedLine);

  obj.passedLine=L.polyline(obj.points,{color:getColor(obj.type),opacity:0.3, weight:2}).addTo(map);

  const last=obj.points[obj.points.length-1];
  
  flashEffect(last, impactRadius[obj.type], getColor(obj.type));
  createExplosionEffect(L.latLng(last[0], last[1]), getColor(obj.type));
  
  let shockwave = L.circle(last, {
    radius: 30,
    color: 'white',
    weight: 1.5,
    fillOpacity: 0,
    opacity: 0.6
  }).addTo(map);
  let r = 30;
  function expandWave() {
    r += 20;
    shockwave.setRadius(r);
    shockwave.setStyle({opacity: 0.6 * (1 - r/impactRadius[obj.type])});
    if(r < impactRadius[obj.type]) requestAnimationFrame(expandWave);
    else map.removeLayer(shockwave);
  }
  expandWave();
  
  obj.impactCircle=L.circle(last,{radius:impactRadius[obj.type],color:getColor(obj.type),fillColor:getColor(obj.type),fillOpacity:0.15, weight:1.5}).addTo(map);

  removeTooltip(obj);
}

function flashEffect(latlng,radius,color){
  let r=8;
  const maxR=radius;
  const flash=L.circle(latlng,{radius:r,color:'white',fillColor:color,fillOpacity:0.8, weight:1}).addTo(map);
  function expand(){
    r+=maxR/12;
    flash.setRadius(r);
    flash.setStyle({fillOpacity:0.6*(1-r/maxR), color:'white'});
    if(r<maxR) requestAnimationFrame(expand);
    else map.removeLayer(flash);
  }
  expand();
}

function resetAll(){
  map.eachLayer(layer=>{
    if(layer instanceof L.Polyline ||
       layer instanceof L.Circle ||
       layer instanceof L.CircleMarker){
      map.removeLayer(layer);
    }
  });
  activeObjects.forEach(o=>removeTooltip(o));
  activeObjects=[]; 
  tempPoints=[];
  tempMarkers.forEach(m=>map.removeLayer(m));
  tempMarkers=[];
}

function calcTotal(points){let d=0;for(let i=0;i<points.length-1;i++) d+=getDistance(points[i],points[i+1]);return d;}
function getDistance(a,b){
  const R=6371;
  const dLat=(b[0]-a[0])*Math.PI/180;
  const dLng=(b[1]-a[1])*Math.PI/180;
  const lat1=a[0]*Math.PI/180;
  const lat2=b[0]*Math.PI/180;
  const x=Math.sin(dLat/2)**2 + Math.sin(dLng/2)**2 * Math.cos(lat1)*Math.cos(lat2);
  return R*2*Math.atan2(Math.sqrt(x),Math.sqrt(1-x));
}

function getColor(type){
  if(type==="drone") return "#00ffff";
  if(type==="cr") return "#ffaa00";
  if(type==="br") return "#ff4444";
  return "#ffffff";
}
</script>

</body>
</html>