<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tactical Defense Elite v11.3</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1"></script>
    <style>
        :root { --primary: #ffbb33; --bg: #0a0c10; --panel-bg: rgba(15, 20, 30, 0.95); --accent: #00e5ff; }
        body, html { height: 100%; width: 100%; background: var(--bg); font-family: 'Segoe UI', sans-serif; overflow: hidden; margin: 0; }
        #map { position: absolute; top: 0; left: 0; height: 100%; width: 100%; z-index: 1; }
        
        .status-header { 
            position: absolute; top: 0; left: 0; width: 100%; z-index: 9999; 
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent); 
            padding: 12px; display: flex; justify-content: center; gap: 25px; color: white; pointer-events: none;
        }
        .status-item { display: flex; align-items: center; gap: 8px; font-size: 13px; font-weight: bold; }

        .ui-layer { position: absolute; top: 50px; width: 100%; z-index: 9998; pointer-events: none; display: flex; flex-direction: column; align-items: center; gap: 12px; }
        .ui-layer > * { pointer-events: auto; }

        .tool-selection { display: flex; gap: 10px; justify-content: center; width: 95%; max-width: 600px; }
        .tool-card { background: var(--panel-bg); border: 2px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 10px; flex: 1; transition: 0.3s; cursor: pointer; }
        .tool-card.active { border-color: var(--primary); box-shadow: 0 0 15px rgba(255,187,51,0.3); }
        .tool-card.active-target { border-color: var(--accent); box-shadow: 0 0 15px rgba(0,229,255,0.3); }
        
        .card-label { font-size: 9px; color: #888; font-weight: 900; margin-bottom: 6px; display: block; text-transform: uppercase; letter-spacing: 1px; }
        .active .card-label { color: var(--primary); }
        .active-target .card-label { color: var(--accent); }

        select { background: #1a222d; color: white; border: 1px solid #444; padding: 8px; border-radius: 6px; font-size: 12px; cursor: pointer; outline: none; width: 100%; }

        .obj-toolbar { position: absolute; background: rgba(0, 10, 20, 0.9); color: #00ffaa; padding: 4px 10px; border-left: 3px solid #00ffaa; font-family: monospace; font-size: 10px; pointer-events: none; z-index: 10000; white-space: nowrap; transform: translate(15px, -15px); }

        .bottom-nav { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; gap: 20px; z-index: 9998; }
        .btn { width: 60px; height: 60px; border-radius: 50%; border: none; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 24px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); transition: 0.2s; }
        
        #playBtn { background: #1a73e8; }
        .btn-confirm { background: #28a745 !important; border: 3px solid #fff !important; transform: scale(1.1); }
        #resetBtn { background: #444; }
    </style>
</head>
<body>
<div id="map"></div>

<div class="status-header">
    <div class="status-item"><i class="far fa-clock"></i> <span id="simTime">00:00</span></div>
    <div class="status-item"><i class="fas fa-bullseye"></i> <span id="targetCount">0</span></div>
    <div class="status-item"><i class="fas fa-shield-alt"></i> <span id="pvoCount">0</span></div>
</div>

<div class="ui-layer">
    <div class="tool-selection">
        <div class="tool-card active" id="pvoCard" onclick="setMode('pvo')">
            <span class="card-label">СИСТЕМА ОБОРОНЫ</span>
            <select id="pvoSelect" onchange="setMode('pvo')">
                <option value="pvo_pancyr">Панцирь-С1 (20 км)</option>
                <option value="pvo_iris">IRIS-T SLM (40 км)</option>
                <option value="pvo_buk">Бук-М3 (70 км)</option>
                <option value="pvo_samp">SAMP/T (100 км)</option>
                <option value="pvo_patriot">Patriot PAC-3 (160 км)</option>
                <option value="pvo_s400">С-400 (400 км)</option>
            </select>
        </div>
        <div class="tool-card" id="targetCard" onclick="setMode('target')">
            <span class="card-label">ТИП УГРОЗЫ</span>
            <select id="targetSelect" onchange="setMode('target')">
                <option value="drone_shahed">Shahed-136 (185 км/ч)</option>
                <option value="missile_x101">Х-101 (850 км/ч)</option>
                <option value="missile_iskander">Искандер-М (7500 км/ч)</option>
                <option value="missile_x32">Х-32 (5400 км/ч)</option>
                <option value="missile_zircon">Циркон (11000 км/ч)</option>
            </select>
        </div>
    </div>
</div>

<div class="bottom-nav">
    <button class="btn" id="resetBtn"><i class="fas fa-sync-alt"></i></button>
    <button class="btn" id="playBtn"><i class="fas fa-play"></i></button>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
    const map = L.map('map', { zoomControl: false, attributionControl: false }).setView([48.8, 36.5], 6);
    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png').addTo(map);

    const CONFIG = {
        drone_shahed: { name: 'SHAHED-136', speed: 185, baseAlt: 150, color: '#00ff88' },
        missile_x101: { name: 'KH-101', speed: 850, baseAlt: 60, color: '#ffbb33' },
        missile_iskander: { name: 'ISKANDER-M', speed: 7500, baseAlt: 40000, color: '#ff4444' },
        missile_x32: { name: 'KH-32', speed: 5400, baseAlt: 30000, color: '#ff00ff' },
        missile_zircon: { name: 'ZIRCON', speed: 11000, baseAlt: 35000, color: '#ff0000' },
        pvo_pancyr: { r: 20, c: '#00ff88' }, pvo_iris: { r: 40, c: '#ff00ff' },
        pvo_buk: { r: 70, c: '#3b82f6' }, pvo_samp: { r: 100, c: '#00e5ff' },
        pvo_patriot: { r: 160, c: '#ffffff' }, pvo_s400: { r: 400, c: '#ff4444' },
        interceptor: { speed: 9500 }
    };

    let state = { currentMode: 'pvo', isSimulating: false, targets: [], pvo: [], missiles: [], pendingPath: [], tempMarkers: [], activeFutureLine: null, simSeconds: 0, lastFrame: 0 };

    function setMode(m) {
        state.currentMode = m;
        document.getElementById('pvoCard').className = 'tool-card' + (m === 'pvo' ? ' active' : '');
        document.getElementById('targetCard').className = 'tool-card' + (m === 'target' ? ' active-target' : '');
    }

    map.on('click', (e) => {
        if (state.isSimulating) return;
        const pos = [e.latlng.lat, e.latlng.lng];
        if (state.currentMode === 'pvo') {
            addPVO(pos, CONFIG[document.getElementById('pvoSelect').value]);
        } else {
            addWaypoint(pos);
        }
        updateNavButtons();
    });

    function addPVO(pos, cfg) {
        const circle = L.circle(pos, { radius: cfg.r * 1000, color: cfg.c, weight: 1, fillOpacity: 0.1 }).addTo(map);
        const marker = L.circleMarker(pos, { radius: 6, color: '#fff', fillColor: cfg.c, fillOpacity: 1 }).addTo(map);
        state.pvo.push({ id: Math.random(), pos, radius: cfg.r, layers: [circle, marker] });
        updateCounters();
    }

    function addWaypoint(pos) {
        const type = document.getElementById('targetSelect').value;
        const marker = L.circleMarker(pos, { radius: 4, color: CONFIG[type].color, fillOpacity: 1 }).addTo(map);
        state.pendingPath.push(pos); 
        state.tempMarkers.push(marker);
        updatePathLine();
    }

    function undoAction() {
        if (state.currentMode === 'target' && state.pendingPath.length > 0) {
            state.pendingPath.pop();
            const m = state.tempMarkers.pop();
            if (m) map.removeLayer(m);
            updatePathLine();
        } else if (state.currentMode === 'pvo' && state.pvo.length > 0) {
            const lastPvo = state.pvo.pop();
            lastPvo.layers.forEach(l => map.removeLayer(l));
            updateCounters();
        }
        updateNavButtons();
    }

    function updatePathLine() {
        if (state.activeFutureLine) map.removeLayer(state.activeFutureLine);
        if (state.pendingPath.length > 0) {
            state.activeFutureLine = L.polyline(state.pendingPath, { color: '#fff', weight: 1, dashArray: '5, 8', opacity: 0.5 }).addTo(map);
        }
    }

    function updateNavButtons() {
        const resetBtn = document.getElementById('resetBtn');
        const playBtn = document.getElementById('playBtn');
        const hasPending = state.pendingPath.length > 0;
        const hasPvo = state.pvo.length > 0;

        // Если есть что отменять (точки цели или установки ПВО)
        if (hasPending || (state.currentMode === 'pvo' && hasPvo)) {
            resetBtn.innerHTML = '<i class="fas fa-undo"></i>';
            resetBtn.onclick = undoAction;
        } else {
            resetBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
            resetBtn.onclick = () => location.reload();
        }

        if (hasPending) {
            playBtn.innerHTML = '<i class="fas fa-check"></i>';
            playBtn.className = 'btn btn-confirm';
        } else {
            playBtn.innerHTML = state.isSimulating ? '<i class="fas fa-pause"></i>' : '<i class="fas fa-play"></i>';
            playBtn.className = 'btn';
        }
    }

    function finalizeTarget() {
        if (state.pendingPath.length < 2) {
            state.pendingPath.forEach((p, i) => map.removeLayer(state.tempMarkers[i]));
            state.pendingPath = []; state.tempMarkers = []; updatePathLine(); updateNavButtons();
            return;
        }
        const type = document.getElementById('targetSelect').value;
        const info = CONFIG[type];
        const target = {
            id: Math.random(), type, path: [...state.pendingPath], speed: info.speed, color: info.color, progressKm: 0,
            currentPos: state.pendingPath[0], totalDist: 0, active: true, toolbar: createTB(),
            marker: L.circleMarker(state.pendingPath[0], { radius: 6, color: '#fff', fillColor: info.color, fillOpacity: 1 }).addTo(map),
            linePast: L.polyline([], { color: info.color, weight: 3 }).addTo(map),
            lineFuture: state.activeFutureLine, // Оставляем ссылку на пунктир
            engagedBy: new Set()
        };
        for(let i=0; i<target.path.length-1; i++) target.totalDist += map.distance(target.path[i], target.path[i+1]) / 1000;
        state.targets.push(target);
        state.pendingPath = []; state.tempMarkers = []; state.activeFutureLine = null;
        updateCounters();
        updateNavButtons();
    }

    function createTB() { const div = document.createElement('div'); div.className = 'obj-toolbar'; document.body.appendChild(div); return div; }

    function simLoop(time) {
        if (!state.isSimulating) return;
        const dt = (time - state.lastFrame) / 1000; state.lastFrame = time;
        const stepHours = (dt * 15) / 3600;

        state.targets.forEach(t => {
            if (!t.active) return;
            t.progressKm += t.speed * stepHours;
            if (t.progressKm >= t.totalDist) { markEvent(t.currentPos, 'hit'); removeT(t); } 
            else {
                t.currentPos = interpolate(t.path, t.progressKm);
                t.marker.setLatLng(t.currentPos);
                t.linePast.setLatLngs(getPoints(t.path, t.progressKm, t.currentPos, true));
                let alt = CONFIG[t.type].baseAlt + (Math.abs(Math.sin(t.currentPos[0]*5))*200);
                if(['missile_iskander', 'missile_zircon', 'missile_x32'].includes(t.type)) alt += Math.sin(t.progressKm/t.totalDist * Math.PI) * 45000;
                t.toolbar.innerHTML = `${CONFIG[t.type].name} | ${t.speed} KM/H | ${Math.round(alt)} M`;
                const p = map.latLngToContainerPoint(t.currentPos);
                t.toolbar.style.left = p.x + 'px'; t.toolbar.style.top = p.y + 'px';
            }
        });

        state.pvo.forEach(p => {
            state.targets.forEach(t => {
                if (!t.active) return;
                const d = map.distance(p.pos, t.currentPos) / 1000;
                if (d < p.radius && !t.engagedBy.has(p.id)) {
                    t.engagedBy.add(p.id);
                    state.missiles.push({ targetId: t.id, pos: [...p.pos], toolbar: createTB(),
                        marker: L.circleMarker(p.pos, { radius: 3, color: '#fff', fillColor: '#ffbb33', fillOpacity: 1 }).addTo(map)
                    });
                }
            });
        });

        state.missiles = state.missiles.filter(m => {
            const t = state.targets.find(target => target.id === m.targetId && target.active);
            if (!t) { map.removeLayer(m.marker); if(m.toolbar) m.toolbar.remove(); return false; }
            const d = map.distance(m.pos, t.currentPos);
            if (d < 1000) { markEvent(t.currentPos, 'intercept'); removeT(t); map.removeLayer(m.marker); m.toolbar.remove(); return false; }
            const move = (CONFIG.interceptor.speed * stepHours * 1000) / d;
            m.pos = [m.pos[0] + (t.currentPos[0] - m.pos[0]) * move, m.pos[1] + (t.currentPos[1] - m.pos[1]) * move];
            m.marker.setLatLng(m.pos);
            const p = map.latLngToContainerPoint(m.pos);
            m.toolbar.style.left = p.x + 'px'; m.toolbar.style.top = p.y + 'px'; m.toolbar.innerHTML = `ЗУР | LOCK`;
            return true;
        });

        state.simSeconds += dt * 15; updateUI();
        requestAnimationFrame(simLoop);
    }

    function markEvent(pos, type) {
        const icon = L.divIcon({ 
            html: type === 'hit' ? 
                '<i class="fas fa-skull" style="color:rgba(255,68,68,0.2);font-size:22px;"></i>' : 
                '<i class="fas fa-certificate" style="color:rgba(255,255,255,0.2);font-size:22px;"></i>', 
            className: 'event-icon', 
            iconSize: [25, 25] 
        });
        L.marker(pos, { icon }).addTo(map);
        if (type === 'intercept') confetti({ particleCount: 30, spread: 60, origin: { y: 0.8 } });
    }

    function getPoints(path, dist, current, past) {
        let acc = 0; let res = past ? [] : [current];
        for(let i=0; i<path.length-1; i++) {
            const d = map.distance(path[i], path[i+1]) / 1000;
            if (past) { res.push(path[i]); if (acc + d > dist) break; }
            acc += d;
        }
        if (past) res.push(current); return res;
    }

    function interpolate(path, dist) {
        let acc = 0;
        for (let i = 0; i < path.length - 1; i++) {
            const d = map.distance(path[i], path[i+1]) / 1000;
            if (acc + d > dist) { const r = (dist - acc) / d; return [path[i][0] + (path[i+1][0] - path[i][0]) * r, path[i][1] + (path[i+1][1] - path[i][1]) * r]; }
            acc += d;
        }
        return path[path.length-1];
    }

    function removeT(t) { 
        t.active = false; 
        map.removeLayer(t.marker); 
        // Линию linePast НЕ удаляем (пунктир остается)
        // Линию lineFuture НЕ удаляем (весь маршрут виден)
        t.toolbar.remove(); 
        updateCounters(); 
    }
    
    document.getElementById('playBtn').onclick = () => {
        if (state.pendingPath.length > 0) finalizeTarget();
        else {
            state.isSimulating = !state.isSimulating;
            const btn = document.getElementById('playBtn');
            if (state.isSimulating) { state.lastFrame = performance.now(); btn.innerHTML = '<i class="fas fa-pause"></i>'; requestAnimationFrame(simLoop); }
            else btn.innerHTML = '<i class="fas fa-play"></i>';
        }
    };

    function updateUI() { const m = Math.floor(state.simSeconds/60); const s = Math.floor(state.simSeconds%60); document.getElementById('simTime').innerText = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`; }
    function updateCounters() { document.getElementById('targetCount').innerText = state.targets.filter(t => t.active).length; document.getElementById('pvoCount').innerText = state.pvo.length; }
    
    document.getElementById('resetBtn').onclick = () => location.reload();
</script>
</body>
</html>
